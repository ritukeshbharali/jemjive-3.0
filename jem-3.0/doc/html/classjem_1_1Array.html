
<!-- Generated on Fri 20 Dec 14:45:31 CET 2019.
     CHANGES TO THIS FILE WILL BE LOST. -->
<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Jem reference manual: jem::Array&lt; T, N &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Jem reference manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacejem.html">jem</a></li><li class="navelem"><a class="el" href="classjem_1_1Array.html">Array</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classjem_1_1Array-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">jem::Array&lt; T, N &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements a multi-dimensional array that supports slicing and array expressions.  
 <a href="classjem_1_1Array.html#details">More...</a></p>

<p><code>#include &lt;jem/base/array/Array.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a43c76805b7fd33715287f423bc85667f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classjem_1_1Tuple.html">Tuple</a>&lt; int, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a43c76805b7fd33715287f423bc85667f">Shape</a></td></tr>
<tr class="memdesc:a43c76805b7fd33715287f423bc85667f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type representing the shape of an array.  <a href="classjem_1_1Array.html#a43c76805b7fd33715287f423bc85667f">More...</a><br /></td></tr>
<tr class="separator:a43c76805b7fd33715287f423bc85667f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb38e7d928e9e3acabbb319a1663b1f8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classjem_1_1ArrayIterator.html">ArrayIterator</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#abb38e7d928e9e3acabbb319a1663b1f8">Iterator</a></td></tr>
<tr class="memdesc:abb38e7d928e9e3acabbb319a1663b1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a> iterator type.  <a href="classjem_1_1Array.html#abb38e7d928e9e3acabbb319a1663b1f8">More...</a><br /></td></tr>
<tr class="separator:abb38e7d928e9e3acabbb319a1663b1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4404e9077142ac318344205c7da4d0b8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classjem_1_1Array.html#abb38e7d928e9e3acabbb319a1663b1f8">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a4404e9077142ac318344205c7da4d0b8">ConstIterator</a></td></tr>
<tr class="memdesc:a4404e9077142ac318344205c7da4d0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only iterator type.  <a href="classjem_1_1Array.html#a4404e9077142ac318344205c7da4d0b8">More...</a><br /></td></tr>
<tr class="separator:a4404e9077142ac318344205c7da4d0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3b65466a8ff9b3f560c66c317759c7f3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a3b65466a8ff9b3f560c66c317759c7f3">Array</a> ()</td></tr>
<tr class="memdesc:a3b65466a8ff9b3f560c66c317759c7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty array.  <a href="classjem_1_1Array.html#a3b65466a8ff9b3f560c66c317759c7f3">More...</a><br /></td></tr>
<tr class="separator:a3b65466a8ff9b3f560c66c317759c7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a944940e131e1441894dae8bba6ec4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a39a944940e131e1441894dae8bba6ec4">Array</a> (int n)</td></tr>
<tr class="memdesc:a39a944940e131e1441894dae8bba6ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a one-dimensional array of a given length.  <a href="classjem_1_1Array.html#a39a944940e131e1441894dae8bba6ec4">More...</a><br /></td></tr>
<tr class="separator:a39a944940e131e1441894dae8bba6ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea5ac1532a85d051d02da11192ecb15"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#afea5ac1532a85d051d02da11192ecb15">Array</a> (int n, int m)</td></tr>
<tr class="memdesc:afea5ac1532a85d051d02da11192ecb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a two-dimensional array with a given shape.  <a href="classjem_1_1Array.html#afea5ac1532a85d051d02da11192ecb15">More...</a><br /></td></tr>
<tr class="separator:afea5ac1532a85d051d02da11192ecb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901e84a559eb1c378f990b1439300c6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a901e84a559eb1c378f990b1439300c6e">Array</a> (int n, int m, int p)</td></tr>
<tr class="memdesc:a901e84a559eb1c378f990b1439300c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a three-dimensional array with a given shape.  <a href="classjem_1_1Array.html#a901e84a559eb1c378f990b1439300c6e">More...</a><br /></td></tr>
<tr class="separator:a901e84a559eb1c378f990b1439300c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab20fbac7ea80f8054b6f83afb5efa8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a6ab20fbac7ea80f8054b6f83afb5efa8">Array</a> (int n, int m, int p, int q)</td></tr>
<tr class="memdesc:a6ab20fbac7ea80f8054b6f83afb5efa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a four-dimensional array with a given shape.  <a href="classjem_1_1Array.html#a6ab20fbac7ea80f8054b6f83afb5efa8">More...</a><br /></td></tr>
<tr class="separator:a6ab20fbac7ea80f8054b6f83afb5efa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05253c97d6fa5771f8e692e19357afe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#ad05253c97d6fa5771f8e692e19357afe">Array</a> (const <a class="el" href="classjem_1_1Array.html#a43c76805b7fd33715287f423bc85667f">Shape</a> &amp;sh)</td></tr>
<tr class="memdesc:ad05253c97d6fa5771f8e692e19357afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an array with a given shape.  <a href="classjem_1_1Array.html#ad05253c97d6fa5771f8e692e19357afe">More...</a><br /></td></tr>
<tr class="separator:ad05253c97d6fa5771f8e692e19357afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc836396df0da27b9616e9a49f0225e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a3dc836396df0da27b9616e9a49f0225e">Array</a> (const <a class="el" href="classjem_1_1Array.html">Array</a> &amp;rhs)</td></tr>
<tr class="memdesc:a3dc836396df0da27b9616e9a49f0225e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shallow copy of another array.  <a href="classjem_1_1Array.html#a3dc836396df0da27b9616e9a49f0225e">More...</a><br /></td></tr>
<tr class="separator:a3dc836396df0da27b9616e9a49f0225e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583965360c8cb6ecf764a4b628c8b2f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a583965360c8cb6ecf764a4b628c8b2f2">Array</a> (const <a class="el" href="classjem_1_1ArrayExpr.html">ArrayExpr</a>&lt; T, N &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a583965360c8cb6ecf764a4b628c8b2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new array given an array expression.  <a href="classjem_1_1Array.html#a583965360c8cb6ecf764a4b628c8b2f2">More...</a><br /></td></tr>
<tr class="separator:a583965360c8cb6ecf764a4b628c8b2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a74ab845b2254f75af70c0cb9c2d83c"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a3a74ab845b2254f75af70c0cb9c2d83c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a3a74ab845b2254f75af70c0cb9c2d83c">Array</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a3a74ab845b2254f75af70c0cb9c2d83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an array given two input iterators.  <a href="classjem_1_1Array.html#a3a74ab845b2254f75af70c0cb9c2d83c">More...</a><br /></td></tr>
<tr class="separator:a3a74ab845b2254f75af70c0cb9c2d83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586e42736c529e9ec616484d632ca745"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a586e42736c529e9ec616484d632ca745">~Array</a> ()</td></tr>
<tr class="memdesc:a586e42736c529e9ec616484d632ca745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates memory if necessary.  <a href="classjem_1_1Array.html#a586e42736c529e9ec616484d632ca745">More...</a><br /></td></tr>
<tr class="separator:a586e42736c529e9ec616484d632ca745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01950e872af4e17e1f8550aed7d9838"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classjem_1_1Array.html">Array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#ab01950e872af4e17e1f8550aed7d9838">operator=</a> (const <a class="el" href="classjem_1_1Array.html">Array</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ab01950e872af4e17e1f8550aed7d9838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of another array.  <a href="classjem_1_1Array.html#ab01950e872af4e17e1f8550aed7d9838">More...</a><br /></td></tr>
<tr class="separator:ab01950e872af4e17e1f8550aed7d9838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77396350e6341002e15b5939af459699"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classjem_1_1Array.html">Array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a77396350e6341002e15b5939af459699">operator=</a> (T rhs) const</td></tr>
<tr class="memdesc:a77396350e6341002e15b5939af459699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all elements of this array to the same value.  <a href="classjem_1_1Array.html#a77396350e6341002e15b5939af459699">More...</a><br /></td></tr>
<tr class="separator:a77396350e6341002e15b5939af459699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d0e4732cbcd32b8b6e7a3dd2e699ae"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classjem_1_1Array.html">Array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a05d0e4732cbcd32b8b6e7a3dd2e699ae">operator=</a> (const <a class="el" href="classjem_1_1ArrayExpr.html">ArrayExpr</a>&lt; T, N &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a05d0e4732cbcd32b8b6e7a3dd2e699ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns an array expression to this array.  <a href="classjem_1_1Array.html#a05d0e4732cbcd32b8b6e7a3dd2e699ae">More...</a><br /></td></tr>
<tr class="separator:a05d0e4732cbcd32b8b6e7a3dd2e699ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e939290df505aef7e64c3f54c0703b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classjem_1_1Array.html#abb38e7d928e9e3acabbb319a1663b1f8">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a2e939290df505aef7e64c3f54c0703b5">begin</a> () const</td></tr>
<tr class="memdesc:a2e939290df505aef7e64c3f54c0703b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the begin of this array.  <a href="classjem_1_1Array.html#a2e939290df505aef7e64c3f54c0703b5">More...</a><br /></td></tr>
<tr class="separator:a2e939290df505aef7e64c3f54c0703b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089e861209b06525bba7eb0955c5494d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classjem_1_1Array.html#abb38e7d928e9e3acabbb319a1663b1f8">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a089e861209b06525bba7eb0955c5494d">end</a> () const</td></tr>
<tr class="memdesc:a089e861209b06525bba7eb0955c5494d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the end of this array.  <a href="classjem_1_1Array.html#a089e861209b06525bba7eb0955c5494d">More...</a><br /></td></tr>
<tr class="separator:a089e861209b06525bba7eb0955c5494d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2514cdb3d071c73eb7beef7c24ea011"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#ab2514cdb3d071c73eb7beef7c24ea011">front</a> () const</td></tr>
<tr class="memdesc:ab2514cdb3d071c73eb7beef7c24ea011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in an array.  <a href="classjem_1_1Array.html#ab2514cdb3d071c73eb7beef7c24ea011">More...</a><br /></td></tr>
<tr class="separator:ab2514cdb3d071c73eb7beef7c24ea011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156109fbd0738589273ae325223a29d2"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a156109fbd0738589273ae325223a29d2">back</a> () const</td></tr>
<tr class="memdesc:a156109fbd0738589273ae325223a29d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in an array.  <a href="classjem_1_1Array.html#a156109fbd0738589273ae325223a29d2">More...</a><br /></td></tr>
<tr class="separator:a156109fbd0738589273ae325223a29d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c4f483378979422c12a23568d16011"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classjem_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#af8c4f483378979422c12a23568d16011">clone</a> () const</td></tr>
<tr class="memdesc:af8c4f483378979422c12a23568d16011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this array.  <a href="classjem_1_1Array.html#af8c4f483378979422c12a23568d16011">More...</a><br /></td></tr>
<tr class="separator:af8c4f483378979422c12a23568d16011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b7b6eea72af226f2be27bef497e560"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a25b7b6eea72af226f2be27bef497e560">ref</a> (const <a class="el" href="classjem_1_1Array.html">Array</a> &amp;rhs)</td></tr>
<tr class="memdesc:a25b7b6eea72af226f2be27bef497e560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shallow assignment of another array.  <a href="classjem_1_1Array.html#a25b7b6eea72af226f2be27bef497e560">More...</a><br /></td></tr>
<tr class="separator:a25b7b6eea72af226f2be27bef497e560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539ad0f46aedf483a0661e1bb50bc7a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a539ad0f46aedf483a0661e1bb50bc7a8">swap</a> (<a class="el" href="classjem_1_1Array.html">Array</a> &amp;rhs)</td></tr>
<tr class="memdesc:a539ad0f46aedf483a0661e1bb50bc7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the data blocks of two arrays.  <a href="classjem_1_1Array.html#a539ad0f46aedf483a0661e1bb50bc7a8">More...</a><br /></td></tr>
<tr class="separator:a539ad0f46aedf483a0661e1bb50bc7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7f142abd03127767f80ce1b5cd9abf"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a7b7f142abd03127767f80ce1b5cd9abf">operator[]</a> (int i) const</td></tr>
<tr class="memdesc:a7b7f142abd03127767f80ce1b5cd9abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element located at a given index.  <a href="classjem_1_1Array.html#a7b7f142abd03127767f80ce1b5cd9abf">More...</a><br /></td></tr>
<tr class="separator:a7b7f142abd03127767f80ce1b5cd9abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32b749006f77e44a26d8eca4318bffa"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:ae32b749006f77e44a26d8eca4318bffa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classjem_1_1Array.html">Array</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#ae32b749006f77e44a26d8eca4318bffa">operator[]</a> (const S &amp;s) const</td></tr>
<tr class="memdesc:ae32b749006f77e44a26d8eca4318bffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a one-dimensional slice of this array.  <a href="classjem_1_1Array.html#ae32b749006f77e44a26d8eca4318bffa">More...</a><br /></td></tr>
<tr class="separator:ae32b749006f77e44a26d8eca4318bffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1007b84a8dd3adda1c963bbb9bef4c78"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a1007b84a8dd3adda1c963bbb9bef4c78">operator()</a> (int i, int j) const</td></tr>
<tr class="memdesc:a1007b84a8dd3adda1c963bbb9bef4c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element located at a given index pair.  <a href="classjem_1_1Array.html#a1007b84a8dd3adda1c963bbb9bef4c78">More...</a><br /></td></tr>
<tr class="separator:a1007b84a8dd3adda1c963bbb9bef4c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f9c3957eac05b2a72e9ef054f05e1c"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a47f9c3957eac05b2a72e9ef054f05e1c">operator()</a> (int i, int j, int k) const</td></tr>
<tr class="memdesc:a47f9c3957eac05b2a72e9ef054f05e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element located at a given index tuple.  <a href="classjem_1_1Array.html#a47f9c3957eac05b2a72e9ef054f05e1c">More...</a><br /></td></tr>
<tr class="separator:a47f9c3957eac05b2a72e9ef054f05e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fc83e5d4dd6bac1a2a00b49e5f3591"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a74fc83e5d4dd6bac1a2a00b49e5f3591">operator()</a> (int i, int j, int k, int p) const</td></tr>
<tr class="memdesc:a74fc83e5d4dd6bac1a2a00b49e5f3591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element located at a given index tuple.  <a href="classjem_1_1Array.html#a74fc83e5d4dd6bac1a2a00b49e5f3591">More...</a><br /></td></tr>
<tr class="separator:a74fc83e5d4dd6bac1a2a00b49e5f3591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ae3a97b6d3e0cec79a2557b6ddc4bd"><td class="memTemplParams" colspan="2">template&lt;class S1 , class S2 &gt; </td></tr>
<tr class="memitem:a69ae3a97b6d3e0cec79a2557b6ddc4bd"><td class="memTemplItemLeft" align="right" valign="top">ArraySlice&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a69ae3a97b6d3e0cec79a2557b6ddc4bd">operator()</a> (const S1 &amp;I, const S2 &amp;J) const</td></tr>
<tr class="memdesc:a69ae3a97b6d3e0cec79a2557b6ddc4bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice of a two-dimensional array.  <a href="classjem_1_1Array.html#a69ae3a97b6d3e0cec79a2557b6ddc4bd">More...</a><br /></td></tr>
<tr class="separator:a69ae3a97b6d3e0cec79a2557b6ddc4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245a69a675909bae6be81e88c670d69b"><td class="memTemplParams" colspan="2">template&lt;class S1 , class S2 , class S3 &gt; </td></tr>
<tr class="memitem:a245a69a675909bae6be81e88c670d69b"><td class="memTemplItemLeft" align="right" valign="top">ArraySlice&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a245a69a675909bae6be81e88c670d69b">operator()</a> (const S1 &amp;I, const S2 &amp;J, const S3 &amp;K) const</td></tr>
<tr class="memdesc:a245a69a675909bae6be81e88c670d69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice of a three-dimensional array.  <a href="classjem_1_1Array.html#a245a69a675909bae6be81e88c670d69b">More...</a><br /></td></tr>
<tr class="separator:a245a69a675909bae6be81e88c670d69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729bf23c298a2343c1685b2946bd4173"><td class="memTemplParams" colspan="2">template&lt;class S1 , class S2 , class S3 , class S4 &gt; </td></tr>
<tr class="memitem:a729bf23c298a2343c1685b2946bd4173"><td class="memTemplItemLeft" align="right" valign="top">ArraySlice&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a729bf23c298a2343c1685b2946bd4173">operator()</a> (const S1 &amp;I, const S2 &amp;J, const S3 &amp;K, const S4 &amp;L) const</td></tr>
<tr class="memdesc:a729bf23c298a2343c1685b2946bd4173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice of a four-dimensional array.  <a href="classjem_1_1Array.html#a729bf23c298a2343c1685b2946bd4173">More...</a><br /></td></tr>
<tr class="separator:a729bf23c298a2343c1685b2946bd4173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec591eab80602216c7a42ec273482f06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classjem_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#aec591eab80602216c7a42ec273482f06">transpose</a> () const</td></tr>
<tr class="memdesc:aec591eab80602216c7a42ec273482f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transpose of this array.  <a href="classjem_1_1Array.html#aec591eab80602216c7a42ec273482f06">More...</a><br /></td></tr>
<tr class="separator:aec591eab80602216c7a42ec273482f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9620d09bf6459f8f02c1ef04d4e746"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classjem_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a1f9620d09bf6459f8f02c1ef04d4e746">transpose</a> (const <a class="el" href="classjem_1_1Tuple.html">Tuple</a>&lt; int, N &gt; &amp;perm) const</td></tr>
<tr class="memdesc:a1f9620d09bf6459f8f02c1ef04d4e746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a generalized transpose of this array.  <a href="classjem_1_1Array.html#a1f9620d09bf6459f8f02c1ef04d4e746">More...</a><br /></td></tr>
<tr class="separator:a1f9620d09bf6459f8f02c1ef04d4e746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357c171ef4a03087138a32a1ce247ff6"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a357c171ef4a03087138a32a1ce247ff6">getFast</a> (int i) const</td></tr>
<tr class="memdesc:a357c171ef4a03087138a32a1ce247ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct data access.  <a href="classjem_1_1Array.html#a357c171ef4a03087138a32a1ce247ff6">More...</a><br /></td></tr>
<tr class="separator:a357c171ef4a03087138a32a1ce247ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b40e1d3430559229015b3599d6915b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a0b40e1d3430559229015b3599d6915b5">isContiguous</a> () const</td></tr>
<tr class="memdesc:a0b40e1d3430559229015b3599d6915b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this array is contiguous.  <a href="classjem_1_1Array.html#a0b40e1d3430559229015b3599d6915b5">More...</a><br /></td></tr>
<tr class="separator:a0b40e1d3430559229015b3599d6915b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f61ffd9580209f112de0a7545654632"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a8f61ffd9580209f112de0a7545654632">resize</a> (int m)</td></tr>
<tr class="memdesc:a8f61ffd9580209f112de0a7545654632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the size of a one-dimensional array.  <a href="classjem_1_1Array.html#a8f61ffd9580209f112de0a7545654632">More...</a><br /></td></tr>
<tr class="separator:a8f61ffd9580209f112de0a7545654632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5193bfbca3662dd0ca9ae70cc9b03b3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a5193bfbca3662dd0ca9ae70cc9b03b3b">resize</a> (int m, int n)</td></tr>
<tr class="memdesc:a5193bfbca3662dd0ca9ae70cc9b03b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the shape of a two-dimensional array.  <a href="classjem_1_1Array.html#a5193bfbca3662dd0ca9ae70cc9b03b3b">More...</a><br /></td></tr>
<tr class="separator:a5193bfbca3662dd0ca9ae70cc9b03b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92954c9f82bd2ab6b511b40d84304de3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a92954c9f82bd2ab6b511b40d84304de3">resize</a> (int m, int n, int p)</td></tr>
<tr class="memdesc:a92954c9f82bd2ab6b511b40d84304de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the shape of a three-dimensional array.  <a href="classjem_1_1Array.html#a92954c9f82bd2ab6b511b40d84304de3">More...</a><br /></td></tr>
<tr class="separator:a92954c9f82bd2ab6b511b40d84304de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47faa30a46eb797ee70d00f0ba233351"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a47faa30a46eb797ee70d00f0ba233351">resize</a> (int m, int n, int p, int q)</td></tr>
<tr class="memdesc:a47faa30a46eb797ee70d00f0ba233351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the shape of a four-dimensional array.  <a href="classjem_1_1Array.html#a47faa30a46eb797ee70d00f0ba233351">More...</a><br /></td></tr>
<tr class="separator:a47faa30a46eb797ee70d00f0ba233351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44d36d065b4b6e4eeb9879a8aa77701"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#ae44d36d065b4b6e4eeb9879a8aa77701">resize</a> (const <a class="el" href="classjem_1_1Array.html#a43c76805b7fd33715287f423bc85667f">Shape</a> &amp;sh)</td></tr>
<tr class="memdesc:ae44d36d065b4b6e4eeb9879a8aa77701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the shape of an array.  <a href="classjem_1_1Array.html#ae44d36d065b4b6e4eeb9879a8aa77701">More...</a><br /></td></tr>
<tr class="separator:ae44d36d065b4b6e4eeb9879a8aa77701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339ca875b6dbde9aeb920f5b5c94eebf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a339ca875b6dbde9aeb920f5b5c94eebf">reshape</a> (int m)</td></tr>
<tr class="memdesc:a339ca875b6dbde9aeb920f5b5c94eebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks or expands a one-dimensional array.  <a href="classjem_1_1Array.html#a339ca875b6dbde9aeb920f5b5c94eebf">More...</a><br /></td></tr>
<tr class="separator:a339ca875b6dbde9aeb920f5b5c94eebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab4a0cce4de5e8b75ce9c5dc8b67db7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a4ab4a0cce4de5e8b75ce9c5dc8b67db7">reshape</a> (int m, int n)</td></tr>
<tr class="memdesc:a4ab4a0cce4de5e8b75ce9c5dc8b67db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks or expands a two-dimensional array.  <a href="classjem_1_1Array.html#a4ab4a0cce4de5e8b75ce9c5dc8b67db7">More...</a><br /></td></tr>
<tr class="separator:a4ab4a0cce4de5e8b75ce9c5dc8b67db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d30a1f58982f02c3f1f2830a53bd16a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a8d30a1f58982f02c3f1f2830a53bd16a">reshape</a> (int m, int n, int p)</td></tr>
<tr class="memdesc:a8d30a1f58982f02c3f1f2830a53bd16a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks or expands a three-dimensional array.  <a href="classjem_1_1Array.html#a8d30a1f58982f02c3f1f2830a53bd16a">More...</a><br /></td></tr>
<tr class="separator:a8d30a1f58982f02c3f1f2830a53bd16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c68b20af49d5205f663298fccc9b99e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a7c68b20af49d5205f663298fccc9b99e">reshape</a> (int m, int n, int p, int q)</td></tr>
<tr class="memdesc:a7c68b20af49d5205f663298fccc9b99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks or expands a four-dimensional array.  <a href="classjem_1_1Array.html#a7c68b20af49d5205f663298fccc9b99e">More...</a><br /></td></tr>
<tr class="separator:a7c68b20af49d5205f663298fccc9b99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6356e3d0c59d9ccb7d57bc44b53e57c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a6356e3d0c59d9ccb7d57bc44b53e57c1">reshape</a> (const <a class="el" href="classjem_1_1Array.html#a43c76805b7fd33715287f423bc85667f">Shape</a> &amp;sh)</td></tr>
<tr class="memdesc:a6356e3d0c59d9ccb7d57bc44b53e57c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks or expands an array.  <a href="classjem_1_1Array.html#a6356e3d0c59d9ccb7d57bc44b53e57c1">More...</a><br /></td></tr>
<tr class="separator:a6356e3d0c59d9ccb7d57bc44b53e57c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a82809f87ae1d823594e5ca4641c02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a89a82809f87ae1d823594e5ca4641c02">size</a> () const</td></tr>
<tr class="memdesc:a89a82809f87ae1d823594e5ca4641c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of a one-dimensional array.  <a href="classjem_1_1Array.html#a89a82809f87ae1d823594e5ca4641c02">More...</a><br /></td></tr>
<tr class="separator:a89a82809f87ae1d823594e5ca4641c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8ddb75562c94efd5d71405b724d680"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#aac8ddb75562c94efd5d71405b724d680">size</a> (int dim) const</td></tr>
<tr class="memdesc:aac8ddb75562c94efd5d71405b724d680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one of the sizes of an array.  <a href="classjem_1_1Array.html#aac8ddb75562c94efd5d71405b724d680">More...</a><br /></td></tr>
<tr class="separator:aac8ddb75562c94efd5d71405b724d680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55303228b2c4da5f070942511bcd9a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#ab55303228b2c4da5f070942511bcd9a1">stride</a> () const</td></tr>
<tr class="memdesc:ab55303228b2c4da5f070942511bcd9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stride of a one-dimensional array.  <a href="classjem_1_1Array.html#ab55303228b2c4da5f070942511bcd9a1">More...</a><br /></td></tr>
<tr class="separator:ab55303228b2c4da5f070942511bcd9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff0f5ed5d706da429e111accee042a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a3ff0f5ed5d706da429e111accee042a8">stride</a> (int dim) const</td></tr>
<tr class="memdesc:a3ff0f5ed5d706da429e111accee042a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one of the strides of an array.  <a href="classjem_1_1Array.html#a3ff0f5ed5d706da429e111accee042a8">More...</a><br /></td></tr>
<tr class="separator:a3ff0f5ed5d706da429e111accee042a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0590d1655d33fe77a7a2321ae4e7bfe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classjem_1_1Array.html#a43c76805b7fd33715287f423bc85667f">Shape</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a0590d1655d33fe77a7a2321ae4e7bfe9">shape</a> () const</td></tr>
<tr class="memdesc:a0590d1655d33fe77a7a2321ae4e7bfe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the shape of this array.  <a href="classjem_1_1Array.html#a0590d1655d33fe77a7a2321ae4e7bfe9">More...</a><br /></td></tr>
<tr class="separator:a0590d1655d33fe77a7a2321ae4e7bfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39987f68c32eaa7af90a3d3571810964"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a39987f68c32eaa7af90a3d3571810964">addr</a> () const</td></tr>
<tr class="memdesc:a39987f68c32eaa7af90a3d3571810964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the data stored in this array.  <a href="classjem_1_1Array.html#a39987f68c32eaa7af90a3d3571810964">More...</a><br /></td></tr>
<tr class="separator:a39987f68c32eaa7af90a3d3571810964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404adc9ce3f1e46399bdf601576704ac"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a404adc9ce3f1e46399bdf601576704ac">addr</a> (int i) const</td></tr>
<tr class="memdesc:a404adc9ce3f1e46399bdf601576704ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a specified element stored in this array.  <a href="classjem_1_1Array.html#a404adc9ce3f1e46399bdf601576704ac">More...</a><br /></td></tr>
<tr class="separator:a404adc9ce3f1e46399bdf601576704ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a77597496f4527fe05635d22caf3f9719"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a77597496f4527fe05635d22caf3f9719">RANK</a> = N</td></tr>
<tr class="memdesc:a77597496f4527fe05635d22caf3f9719"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rank of the <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> class.  <a href="classjem_1_1Array.html#a77597496f4527fe05635d22caf3f9719">More...</a><br /></td></tr>
<tr class="separator:a77597496f4527fe05635d22caf3f9719"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td colspan="2"><div class="groupHeader">Shape construction functions</div></td></tr>
<tr class="memitem:af02e430770bc879a14382e43503e66bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classjem_1_1Tuple.html">Tuple</a>&lt; int, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#af02e430770bc879a14382e43503e66bf">shape</a> (int n)</td></tr>
<tr class="memdesc:af02e430770bc879a14382e43503e66bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a one-dimensional shape object.  <a href="classjem_1_1Array.html#af02e430770bc879a14382e43503e66bf">More...</a><br /></td></tr>
<tr class="separator:af02e430770bc879a14382e43503e66bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad995d4f79f78b0cd9e7dcceb55f8b6d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classjem_1_1Tuple.html">Tuple</a>&lt; int, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#ad995d4f79f78b0cd9e7dcceb55f8b6d0">shape</a> (int m, int n)</td></tr>
<tr class="memdesc:ad995d4f79f78b0cd9e7dcceb55f8b6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a two-dimensional shape object.  <a href="classjem_1_1Array.html#ad995d4f79f78b0cd9e7dcceb55f8b6d0">More...</a><br /></td></tr>
<tr class="separator:ad995d4f79f78b0cd9e7dcceb55f8b6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89cccf85e51fdcfea7d9c97a64e4473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classjem_1_1Tuple.html">Tuple</a>&lt; int, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#aa89cccf85e51fdcfea7d9c97a64e4473">shape</a> (int m, int n, int p)</td></tr>
<tr class="memdesc:aa89cccf85e51fdcfea7d9c97a64e4473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a three-dimensional shape object.  <a href="classjem_1_1Array.html#aa89cccf85e51fdcfea7d9c97a64e4473">More...</a><br /></td></tr>
<tr class="separator:aa89cccf85e51fdcfea7d9c97a64e4473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24c4514db0abec13ebdd0089b584213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classjem_1_1Tuple.html">Tuple</a>&lt; int, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#ad24c4514db0abec13ebdd0089b584213">shape</a> (int m, int n, int p, int q)</td></tr>
<tr class="memdesc:ad24c4514db0abec13ebdd0089b584213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a four-dimensional shape object.  <a href="classjem_1_1Array.html#ad24c4514db0abec13ebdd0089b584213">More...</a><br /></td></tr>
<tr class="separator:ad24c4514db0abec13ebdd0089b584213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Input and output operators</div></td></tr>
<tr class="memitem:af9fb26ba923cb1e707327259760f9c54"><td class="memTemplParams" colspan="2">template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:af9fb26ba923cb1e707327259760f9c54"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classjem_1_1io_1_1DataInput.html">io::DataInput</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#af9fb26ba923cb1e707327259760f9c54">operator&gt;&gt;</a> (<a class="el" href="classjem_1_1io_1_1DataInput.html">io::DataInput</a> &amp;in, <a class="el" href="classjem_1_1Array.html">Array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:af9fb26ba923cb1e707327259760f9c54"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a> de-serialization operator.  <a href="classjem_1_1Array.html#af9fb26ba923cb1e707327259760f9c54">More...</a><br /></td></tr>
<tr class="separator:af9fb26ba923cb1e707327259760f9c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aef2fdbf23aed7476587eb153baf529"><td class="memTemplParams" colspan="2">template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:a2aef2fdbf23aed7476587eb153baf529"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classjem_1_1io_1_1DataOutput.html">io::DataOutput</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a2aef2fdbf23aed7476587eb153baf529">operator&lt;&lt;</a> (<a class="el" href="classjem_1_1io_1_1DataOutput.html">io::DataOutput</a> &amp;out, const <a class="el" href="classjem_1_1Array.html">Array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:a2aef2fdbf23aed7476587eb153baf529"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a> serialization operator.  <a href="classjem_1_1Array.html#a2aef2fdbf23aed7476587eb153baf529">More...</a><br /></td></tr>
<tr class="separator:a2aef2fdbf23aed7476587eb153baf529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b56dc7bb1b98575c94b7f8c3b4e2dca"><td class="memTemplParams" colspan="2">template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:a6b56dc7bb1b98575c94b7f8c3b4e2dca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classjem_1_1io_1_1TextOutput.html">io::TextOutput</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjem_1_1Array.html#a6b56dc7bb1b98575c94b7f8c3b4e2dca">operator&lt;&lt;</a> (<a class="el" href="classjem_1_1io_1_1TextOutput.html">io::TextOutput</a> &amp;out, const <a class="el" href="classjem_1_1Array.html">Array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:a6b56dc7bb1b98575c94b7f8c3b4e2dca"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a> print operator.  <a href="classjem_1_1Array.html#a6b56dc7bb1b98575c94b7f8c3b4e2dca">More...</a><br /></td></tr>
<tr class="separator:a6b56dc7bb1b98575c94b7f8c3b4e2dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, int N&gt;<br />
class jem::Array&lt; T, N &gt;</h3>

<p>The <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> class represents a multi-dimensional array of objects. It is a template class with two template parameters. The first parameter, <em>T</em>, specifies the type of the objects stored in the array. This type should define a default constructor and a copy constructor. The second parameter, <em>N</em>, specifies the <em>rank</em> &ndash; i.e. the number of dimensions &ndash; of the array. At this time, arrays up to rank four are supported. If the rank parameter is omitted, a default value of one is assumed.</p>
<p>Each array has a <em>shape</em> : an integer <code><a class="el" href="classjem_1_1Tuple.html" title="Encapsulates a fixed-size, two-dimensional array.">Tuple</a></code> of length equal to the rank of the array. The elements of this <code><a class="el" href="classjem_1_1Tuple.html" title="Encapsulates a fixed-size, two-dimensional array.">Tuple</a></code> specify the sizes of the array in each dimension. For instance, a three-dimensional array with shape <em>(10,3,5)</em> has size 10 in the first dimension, size 3 in the second dimension and size 5 in the third dimension.</p>
<p>The elements in an array are identified in the usual way by a set of integer indices ranging from zero to the corresponding array size minus one. Thus, the index pair <em>(1,0)</em> identifies the second element in the first column of a two-dimensional array.</p>
<p>An array stores its elements in a data block that may be shared with one or more other arrays. As a consequence, multiple arrays may provide different views to parts of the same data. For instance, a one-dimensional array may provide access to one column of a two-dimensional array. Another consequence of the shared storage scheme is that the elements of an array may be modified by modifying the elements of another array. In most cases this is the behavior one would expect, but in some cases it may lead to unexpected results. One should therefore always be aware that multiple arrays may share the same data.</p>
<p>The <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> class provides a set of overloaded subscript and function-call operators that can be used to access the elements of an array. The <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> class also provides a set of member functions that provide direct access to the data block pointed to by an array. Although one is advised to avoid these functions, they can be useful in the case that you need to pass the contents of an array to a function that expects a standard C/C++ array. They can also be useful to write optimized code sections that avoid redundant index calculations.</p>
<p>More information on using the <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> class is provided in the following sections:</p>
<ul>
<li><a class="el" href="ArraySlices.html">Array slices</a> - how to select regular sections of an array.</li>
</ul>
<ul>
<li><a class="el" href="group__ArraySelections.html">Array selections</a> - how to select non-regular sections of an array.</li>
</ul>
<ul>
<li><a class="el" href="ArrayExpressions.html">Array expressions</a> - how to perform complex operations using simple array expressions.</li>
</ul>
<ul>
<li><a class="el" href="ArrayAssignmentOperators.html">Array assignment operators</a> - additional assignment operators that are not member functions of the <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> class.</li>
</ul>
<ul>
<li><a class="el" href="group__ArrayUtilities.html">Array utility functions</a> - a collection of handy functions that operate on arrays.</li>
</ul>
<ul>
<li><a class="el" href="ArrayHeaders.html">Array header files</a> - which header files should be included into your source files.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> class uses a non-thread safe reference countaing scheme for sharing data blocks. This means that you should be very careful when using concurrent threads that manipulate the same array data block. The best way to avoid disastrous race conditions is not to share arrays between threads.</dd>
<dd>
The <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> class actually has three template arguments. The third argument &ndash; which by default equals the class <code><a class="el" href="classjem_1_1Nil.html" title="Represents a null pointer.">Nil</a></code> &ndash; is used to implement <a class="el" href="ArrayExpressions.html">array expressions</a> and is normally not visible to users of the <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> class.</dd>
<dd>
All the subscript operators of the <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> class return non-const references even though the operators are declared as a const member functions. The reason is that multiple arrays may point to the same data block. Consequently, one could easily modify the elements of a const <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> through a non-const <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> that points to the same data block.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classjem_1_1ArrayExpr.html" title="A dummy class representing array expressions.">ArrayExpr</a></code>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Array_8cpp-example.html#_a3">Array.cpp</a>, and <a class="el" href="game-of-life_8cpp-example.html#_a1">game-of-life.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a43c76805b7fd33715287f423bc85667f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c76805b7fd33715287f423bc85667f">&#9670;&nbsp;</a></span>Shape</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classjem_1_1Tuple.html">Tuple</a>&lt;int,N&gt; <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::<a class="el" href="classjem_1_1Array.html#a43c76805b7fd33715287f423bc85667f">Shape</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <code>Shape</code> type represents the shape of an array. It is an alias for <code>Tuple&lt;int,N&gt;</code>. </p>

</div>
</div>
<a id="abb38e7d928e9e3acabbb319a1663b1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb38e7d928e9e3acabbb319a1663b1f8">&#9670;&nbsp;</a></span>Iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classjem_1_1ArrayIterator.html">ArrayIterator</a>&lt;T,N&gt; <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::<a class="el" href="classjem_1_1Array.html#abb38e7d928e9e3acabbb319a1663b1f8">Iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An iterator type pointing to elements of type <em>T</em>. This iterator type fulfills the requirements of the bi-directional iterator category of the standard C++ library. If the array rank <em>N</em> equals one, the iterator type fulfills the requirements of the random access iterator category of the standard C++ library.</p>
<p>An iterator of a multi-dimensional array traverses that array in column-major order. That is, the array index in the first dimension varies fastest while the array index in the last dimension varies slowest. </p>

</div>
</div>
<a id="a4404e9077142ac318344205c7da4d0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4404e9077142ac318344205c7da4d0b8">&#9670;&nbsp;</a></span>ConstIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classjem_1_1Array.html#abb38e7d928e9e3acabbb319a1663b1f8">Iterator</a> <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::<a class="el" href="classjem_1_1Array.html#a4404e9077142ac318344205c7da4d0b8">ConstIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an alias for the <code>Iterator</code> type. The <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> class does not provide a separate read-only iterator type since multiple arrays may share the same data. Thus, one can easily modify the elements of an array even if that array is declared constant. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3b65466a8ff9b3f560c66c317759c7f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b65466a8ff9b3f560c66c317759c7f3">&#9670;&nbsp;</a></span>Array() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::<a class="el" href="classjem_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an empty array.</p>
<dl class="section post"><dt>Postcondition</dt><dd><code>sum( abs( shape() ) ) == 0</code> </dd></dl>

</div>
</div>
<a id="a39a944940e131e1441894dae8bba6ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a944940e131e1441894dae8bba6ec4">&#9670;&nbsp;</a></span>Array() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::<a class="el" href="classjem_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a one-dimensional array with length <em>n</em>. The elements of the array are initialized by the default constructor of type <em>T</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- an integer specifying the length of the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> RANK == 1 &amp;&amp; <br  />
 n &gt;= 0 </code> <br  />
 and the type <em>T</em> has a default constructor.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code> this-&gt;<a class="el" href="classjem_1_1Array.html#a89a82809f87ae1d823594e5ca4641c02" title="Returns the size of a one-dimensional array.">size()</a> == n &amp;&amp; <br  />
 this-&gt;<a class="el" href="classjem_1_1Array.html#a0b40e1d3430559229015b3599d6915b5" title="Tests whether this array is contiguous.">isContiguous()</a> </code> </dd></dl>

</div>
</div>
<a id="afea5ac1532a85d051d02da11192ecb15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea5ac1532a85d051d02da11192ecb15">&#9670;&nbsp;</a></span>Array() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::<a class="el" href="classjem_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a two-dimensional array with shape <em>(m,n)</em>. The elements of the array are initialized by the default constructor of type <em>T</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>- an integer specifying the size of the array in the first dimension.</td></tr>
    <tr><td class="paramname">n</td><td>- an integer specifying the size of the array in the second dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> RANK == 2 &amp;&amp; <br  />
 m &gt;= 0 &amp;&amp; <br  />
 n &gt;= 0 </code> <br  />
 and the type <em>T</em> has a default constructor.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code> this-&gt;size(0) == m &amp;&amp; <br  />
 this-&gt;size(1) == n &amp;&amp; <br  />
 this-&gt;<a class="el" href="classjem_1_1Array.html#a0b40e1d3430559229015b3599d6915b5" title="Tests whether this array is contiguous.">isContiguous()</a> </code> </dd></dl>

</div>
</div>
<a id="a901e84a559eb1c378f990b1439300c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901e84a559eb1c378f990b1439300c6e">&#9670;&nbsp;</a></span>Array() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::<a class="el" href="classjem_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a three-dimensional array with shape <em>(m,n,p)</em>. The elements of the array are initialized by the default constructor of type <em>T</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>- an integer specifying the size of the array in the first dimension.</td></tr>
    <tr><td class="paramname">n</td><td>- an integer specifying the size of the array in the second dimension.</td></tr>
    <tr><td class="paramname">p</td><td>- an integer specifying the size of the array in the third dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> RANK == 3 &amp;&amp; <br  />
 m &gt;= 0 &amp;&amp; <br  />
 n &gt;= 0 &amp;&amp; <br  />
 p &gt;= 0 </code> <br  />
 and the type <em>T</em> has a default constructor.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code> this-&gt;size(0) == m &amp;&amp; <br  />
 this-&gt;size(1) == n &amp;&amp; <br  />
 this-&gt;size(2) == p &amp;&amp; <br  />
 this-&gt;<a class="el" href="classjem_1_1Array.html#a0b40e1d3430559229015b3599d6915b5" title="Tests whether this array is contiguous.">isContiguous()</a> </code> </dd></dl>

</div>
</div>
<a id="a6ab20fbac7ea80f8054b6f83afb5efa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab20fbac7ea80f8054b6f83afb5efa8">&#9670;&nbsp;</a></span>Array() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::<a class="el" href="classjem_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a four-dimensional array with shape <em>(m,n,p,q)</em>. The elements of the array are initialized by the default constructor of type <em>T</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>- an integer specifying the size of the array in the first dimension.</td></tr>
    <tr><td class="paramname">n</td><td>- an integer specifying the size of the array in the second dimension.</td></tr>
    <tr><td class="paramname">p</td><td>- an integer specifying the size of the array in the third dimension.</td></tr>
    <tr><td class="paramname">q</td><td>- an integer specifying the size of the array in the fourth dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> RANK == 4 &amp;&amp; <br  />
 m &gt;= 0 &amp;&amp; <br  />
 n &gt;= 0 &amp;&amp; <br  />
 p &gt;= 0 &amp;&amp; <br  />
 q &gt;= 0 </code> <br  />
 and the type <em>T</em> has a default constructor.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code> this-&gt;size(0) == m &amp;&amp; <br  />
 this-&gt;size(1) == n &amp;&amp; <br  />
 this-&gt;size(2) == p &amp;&amp; <br  />
 this-&gt;size(3) == q &amp;&amp; <br  />
 this-&gt;<a class="el" href="classjem_1_1Array.html#a0b40e1d3430559229015b3599d6915b5" title="Tests whether this array is contiguous.">isContiguous()</a> </code> </dd></dl>

</div>
</div>
<a id="ad05253c97d6fa5771f8e692e19357afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05253c97d6fa5771f8e692e19357afe">&#9670;&nbsp;</a></span>Array() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::<a class="el" href="classjem_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1Array.html#a43c76805b7fd33715287f423bc85667f">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>sh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an <em>N-dimensional</em> array with shape <em>sh</em>. The elements of the array are initialized by the default constructor of type <em>T</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sh</td><td>- the shape of the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>min(sh) &gt;= 0</code> <br  />
 and the type <em>T</em> has a default constructor.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code> equal( this-&gt;<a class="el" href="classjem_1_1Array.html#a0590d1655d33fe77a7a2321ae4e7bfe9" title="Returns the shape of this array.">shape()</a>, sh ) &amp;&amp; </code> <br  />
 <code>this-&gt;<a class="el" href="classjem_1_1Array.html#a0b40e1d3430559229015b3599d6915b5" title="Tests whether this array is contiguous.">isContiguous()</a> </code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>jem::shape()</code>. </dd></dl>

</div>
</div>
<a id="a3dc836396df0da27b9616e9a49f0225e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc836396df0da27b9616e9a49f0225e">&#9670;&nbsp;</a></span>Array() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::<a class="el" href="classjem_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1Array.html">Array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The copy constructor of the <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> class creates a <em>shallow</em> copy of the <em>rhs</em> array. This means that the newly created array points to the same data block as the original array. Any modifications in the new array will therefore be visible in the original array, and the other way around.</p>
<p>Because of the shallow copy semantics, returning an array from a function is a relatively cheap operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>- an <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a583965360c8cb6ecf764a4b628c8b2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583965360c8cb6ecf764a4b628c8b2f2">&#9670;&nbsp;</a></span>Array() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::<a class="el" href="classjem_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1ArrayExpr.html">ArrayExpr</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an array from the array expression <em>rhs</em>. In contrast to the copy constructor, this constructor has deep copy semantics. This means that the new array does not share its data with the array expression.</p>
<p>The newly created array has the same shape as the <em>rhs</em> array expression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>- an <a class="el" href="ArrayExpressions.html">array expression</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code> equal( this-&gt;<a class="el" href="classjem_1_1Array.html#a0590d1655d33fe77a7a2321ae4e7bfe9" title="Returns the shape of this array.">shape()</a>, rhs.shape() ) &amp;&amp; <br  />
 this-&gt;<a class="el" href="classjem_1_1Array.html#a0b40e1d3430559229015b3599d6915b5" title="Tests whether this array is contiguous.">isContiguous()</a> </code> </dd></dl>

</div>
</div>
<a id="a3a74ab845b2254f75af70c0cb9c2d83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a74ab845b2254f75af70c0cb9c2d83c">&#9670;&nbsp;</a></span>Array() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::<a class="el" href="classjem_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a one-dimensional array containing copies of the elements between the input iterators <em>first</em> and <em>last</em>. The elements are copied by calling the copy constructor of type <em>T</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>- an input iterator pointing to the first element to be copied into the new array.</td></tr>
    <tr><td class="paramname">last</td><td>- an input iterator pointing one position past the last element to be copied into this array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>RANK == 1</code> <br  />
 and the type <em>T</em> has a copy constructor, <br  />
 and the input iterator <em>last</em> is reachable from <em>first</em>.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code> this-&gt;<a class="el" href="classjem_1_1Array.html#a89a82809f87ae1d823594e5ca4641c02" title="Returns the size of a one-dimensional array.">size()</a> == std::distance( first, last ) &amp;&amp; <br  />
 this-&gt;<a class="el" href="classjem_1_1Array.html#a0b40e1d3430559229015b3599d6915b5" title="Tests whether this array is contiguous.">isContiguous()</a> </code> </dd></dl>

</div>
</div>
<a id="a586e42736c529e9ec616484d632ca745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586e42736c529e9ec616484d632ca745">&#9670;&nbsp;</a></span>~Array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::~<a class="el" href="classjem_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The destructor of the <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> class will deallocate the data block this array is pointing to if no other arrays are pointing to the same data block. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab01950e872af4e17e1f8550aed7d9838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01950e872af4e17e1f8550aed7d9838">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classjem_1_1Array.html">Array</a>&amp; <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1Array.html">Array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements of the <em>rhs</em> array into this array. To be precise, the elements of the <em>rhs</em> array are copied into the data block this array is pointing to. The memory areas pointed to by the <em>rhs</em> array and this array should not overlap.</p>
<p>The elements are copied by calling the assignment operator of type <em>T</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>- the array to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>equals( this-&gt;<a class="el" href="classjem_1_1Array.html#a0590d1655d33fe77a7a2321ae4e7bfe9" title="Returns the shape of this array.">shape()</a>, rhs.shape() )</code> <br  />
 and the type <em>T</em> has an assignment operator.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In contrast to the copy constructor, the assignment operator of the <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> class has deep copy semantics.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ArrayAssignmentOperators.html">Array assignment operators</a>. </dd></dl>

</div>
</div>
<a id="a77396350e6341002e15b5939af459699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77396350e6341002e15b5939af459699">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classjem_1_1Array.html">Array</a>&amp; <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns all elements of this array the value <em>rhs</em> by calling the assignment operator of type <em>T</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>- the value to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The type <em>T</em> has an assignment operator.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ArrayAssignmentOperators.html">Array assignment operators</a>. </dd></dl>

</div>
</div>
<a id="a05d0e4732cbcd32b8b6e7a3dd2e699ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d0e4732cbcd32b8b6e7a3dd2e699ae">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classjem_1_1Array.html">Array</a>&amp; <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1ArrayExpr.html">ArrayExpr</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements of the array expression <em>rhs</em> into this array. To be precise, the elements of the <em>rhs</em> array expression are copied into the data block this array is pointing to.</p>
<p>The elements are copied by calling the assignment operator of type <em>T</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>- an <a class="el" href="ArrayExpressions.html">array expression</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>equal( this-&gt;<a class="el" href="classjem_1_1Array.html#a0590d1655d33fe77a7a2321ae4e7bfe9" title="Returns the shape of this array.">shape()</a>, rhs.shape() )</code> <br  />
 and the type <em>T</em> has an assignment operator.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ArrayAssignmentOperators.html">Array assignment operators</a>. </dd></dl>

</div>
</div>
<a id="a2e939290df505aef7e64c3f54c0703b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e939290df505aef7e64c3f54c0703b5">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Array.html#abb38e7d928e9e3acabbb319a1663b1f8">Iterator</a> <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator pointing to the first element in this array, or <code><a class="el" href="classjem_1_1Array.html#a089e861209b06525bba7eb0955c5494d" title="Returns an iterator pointing to the end of this array.">end()</a></code> if this array is empty. The iterator is valid as long as the data block pointed to by this array is not deallocated.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element in this array, or <code><a class="el" href="classjem_1_1Array.html#a089e861209b06525bba7eb0955c5494d" title="Returns an iterator pointing to the end of this array.">end()</a></code> if the array is empty. </dd></dl>

</div>
</div>
<a id="a089e861209b06525bba7eb0955c5494d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089e861209b06525bba7eb0955c5494d">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Array.html#abb38e7d928e9e3acabbb319a1663b1f8">Iterator</a> <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator pointing one position past the last element in this array. The iterator is valid as long as the data block pointed to by this array is not deallocated.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing one position past the last element in this array. </dd></dl>

</div>
</div>
<a id="ab2514cdb3d071c73eb7beef7c24ea011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2514cdb3d071c73eb7beef7c24ea011">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a reference to the first element in a one-dimensional array. This reference is valid as long as the data block pointed to by this array is not deallocated.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the first element in this array: <code>(*this)[0]</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> RANK == 1 &amp;&amp; <br  />
 this-&gt;<a class="el" href="classjem_1_1Array.html#a89a82809f87ae1d823594e5ca4641c02" title="Returns the size of a one-dimensional array.">size()</a> &gt; 0 </code> </dd></dl>

</div>
</div>
<a id="a156109fbd0738589273ae325223a29d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156109fbd0738589273ae325223a29d2">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a reference to the last element in a one-dimensional array. This reference is valid as long as the data block pointed to by this array is not deallocated.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the last element in this array: <code>(*this)[ <a class="el" href="classjem_1_1Array.html#a89a82809f87ae1d823594e5ca4641c02" title="Returns the size of a one-dimensional array.">size()</a> - 1 ]</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> RANK == 1 &amp;&amp; <br  />
 this-&gt;<a class="el" href="classjem_1_1Array.html#a89a82809f87ae1d823594e5ca4641c02" title="Returns the size of a one-dimensional array.">size()</a> &gt; 0 </code> </dd></dl>

</div>
</div>
<a id="af8c4f483378979422c12a23568d16011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c4f483378979422c12a23568d16011">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Array.html">Array</a> <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a deep copy of this array. That is, the returned array contains copies of the elements in this array. The returned array is guaranteed to be contiguous. In other words:</p>
<p><code><a class="el" href="classjem_1_1Array.html#af8c4f483378979422c12a23568d16011" title="Creates a deep copy of this array.">clone()</a>.<a class="el" href="classjem_1_1Array.html#a0b40e1d3430559229015b3599d6915b5" title="Tests whether this array is contiguous.">isContiguous()</a> == true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A deep copy of this array.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classjem_1_1Array.html#a0b40e1d3430559229015b3599d6915b5" title="Tests whether this array is contiguous.">isContiguous()</a></code>. </dd></dl>

</div>
</div>
<a id="a25b7b6eea72af226f2be27bef497e560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b7b6eea72af226f2be27bef497e560">&#9670;&nbsp;</a></span>ref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::ref </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1Array.html">Array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>After calling the <code>ref</code> member function, this array will point to the same data block as the <em>rhs</em> array. Consequently, any modifications to this array will be visible in the <em>rhs</em> array, and the other way around.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>- an array of the same rank as this array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code> equals( this-&gt;<a class="el" href="classjem_1_1Array.html#a0590d1655d33fe77a7a2321ae4e7bfe9" title="Returns the shape of this array.">shape()</a>, rhs.shape() ) &amp;&amp; <br  />
 this-&gt;<a class="el" href="classjem_1_1Array.html#a39987f68c32eaa7af90a3d3571810964" title="Returns a pointer to the data stored in this array.">addr()</a> == rhs.addr() </code> </dd></dl>

</div>
</div>
<a id="a539ad0f46aedf483a0661e1bb50bc7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539ad0f46aedf483a0661e1bb50bc7a8">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjem_1_1Array.html">Array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swaps the data blocks and shapes of this array and the <em>rhs</em> array. Thus, after calling the member <code>swap</code>, this array has the shape of the <em>rhs</em> array and points to the data block of that array. Conversely, the <em>rhs</em> array has the shape of this array and points to the data block of this array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>- an array of the same rank as this array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b7f142abd03127767f80ce1b5cd9abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7f142abd03127767f80ce1b5cd9abf">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a reference to the <em>i-th</em> element of a one-dimensional array. This reference is valid as long as the data block pointed to by this array is not deallocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>- a valid array index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="classjem_1_1Array.html#a39987f68c32eaa7af90a3d3571810964" title="Returns a pointer to the data stored in this array.">addr()</a>[ i * <a class="el" href="classjem_1_1Array.html#ab55303228b2c4da5f070942511bcd9a1" title="Returns the stride of a one-dimensional array.">stride()</a> ]</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> RANK == 1 &amp;&amp; <br  />
 i &gt;= 0 &amp;&amp; i &lt; this-&gt;<a class="el" href="classjem_1_1Array.html#a89a82809f87ae1d823594e5ca4641c02" title="Returns the size of a one-dimensional array.">size()</a> </code> </dd></dl>

</div>
</div>
<a id="ae32b749006f77e44a26d8eca4318bffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32b749006f77e44a26d8eca4318bffa">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
<div class="memtemplate">
template&lt;class S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Array.html">Array</a> <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a one-dimensional <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> object that refers to a section of this array. This operator is only supported by one-dimensional arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- a <code><a class="el" href="classjem_1_1Slice.html" title="Selects parts of array-like objects.">Slice</a></code> instance or an instance of a class derived from <code><a class="el" href="classjem_1_1Slice.html" title="Selects parts of array-like objects.">Slice</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A slice of this array.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>RANK == 1</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ArraySlices.html">Array slices</a>. </dd></dl>

</div>
</div>
<a id="a1007b84a8dd3adda1c963bbb9bef4c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1007b84a8dd3adda1c963bbb9bef4c78">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a reference to the element <em>(i,j)</em> of a two-dimensional array. The reference is valid as long as the data block pointed to by this array is not deallocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>- a valid array index in the first dimension.</td></tr>
    <tr><td class="paramname">j</td><td>- a valid array index in the second dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="classjem_1_1Array.html#a39987f68c32eaa7af90a3d3571810964" title="Returns a pointer to the data stored in this array.">addr()</a>[ i * stride(0) + j * stride(1) ]</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> RANK == 2 &amp;&amp; <br  />
 i &gt;= 0 &amp;&amp; i &lt; this-&gt;size(0) &amp;&amp; <br  />
 j &gt;= 0 &amp;&amp; j &lt; this-&gt;size(1) </code> </dd></dl>

</div>
</div>
<a id="a47f9c3957eac05b2a72e9ef054f05e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f9c3957eac05b2a72e9ef054f05e1c">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a reference to the element <em>(i,j,k)</em> of a three-dimensional array. This reference is valid as long as the data block pointed to by this array is not deallocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>- a valid array index in the first dimension.</td></tr>
    <tr><td class="paramname">j</td><td>- a valid array index in the second dimension.</td></tr>
    <tr><td class="paramname">k</td><td>- a valid array index in the third dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="classjem_1_1Array.html#a39987f68c32eaa7af90a3d3571810964" title="Returns a pointer to the data stored in this array.">addr()</a>[ i * stride(0) + j * stride(1) + k * stride(2) ]</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> RANK == 3 &amp;&amp; <br  />
 i &gt;= 0 &amp;&amp; i &lt; this-&gt;size(0) &amp;&amp; <br  />
 j &gt;= 0 &amp;&amp; j &lt; this-&gt;size(1) &amp;&amp; <br  />
 k &gt;= 0 &amp;&amp; k &lt; this-&gt;size(2) </code> </dd></dl>

</div>
</div>
<a id="a74fc83e5d4dd6bac1a2a00b49e5f3591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74fc83e5d4dd6bac1a2a00b49e5f3591">&#9670;&nbsp;</a></span>operator()() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a reference to the element <em>(i,j,k,p)</em> of a four-dimensional array. This reference is valid as long as the data block pointed to by this array is not deallocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>- a valid array index in the first dimension.</td></tr>
    <tr><td class="paramname">j</td><td>- a valid array index in the second dimension.</td></tr>
    <tr><td class="paramname">k</td><td>- a valid array index in the third dimension.</td></tr>
    <tr><td class="paramname">p</td><td>- a valid array index in the fourth dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="classjem_1_1Array.html#a39987f68c32eaa7af90a3d3571810964" title="Returns a pointer to the data stored in this array.">addr()</a>[ i * stride(0) + j * stride(1) + k * stride(2) + p * stride(3) ]</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> RANK == 4 &amp;&amp; <br  />
 i &gt;= 0 &amp;&amp; i &lt; this-&gt;size(0) &amp;&amp; <br  />
 j &gt;= 0 &amp;&amp; j &lt; this-&gt;size(1) &amp;&amp; <br  />
 k &gt;= 0 &amp;&amp; k &lt; this-&gt;size(2) &amp;&amp; <br  />
 p &gt;= 0 &amp;&amp; p &lt; this-&gt;size(3) </code> </dd></dl>

</div>
</div>
<a id="a69ae3a97b6d3e0cec79a2557b6ddc4bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ae3a97b6d3e0cec79a2557b6ddc4bd">&#9670;&nbsp;</a></span>operator()() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
<div class="memtemplate">
template&lt;class S1 , class S2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArraySlice <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const S1 &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S2 &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a one-dimensional or two-dimensional <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> object that refers to a rectangular section of this two-dimensional array. The returned array points to the same data block as this array.</p>
<p>Note that the return type <code>ArraySlice</code> is a dummy type; depending on the types of the template parameters <em>S1</em> and <em>S2</em>, <code>ArraySlice</code> is either equal to <code>Array&lt;T,1&gt;</code> or <code>Array&lt;T,2&gt;</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I</td><td>- a <code><a class="el" href="classjem_1_1Slice.html" title="Selects parts of array-like objects.">Slice</a></code> or a valid integer index in the first dimension</td></tr>
    <tr><td class="paramname">J</td><td>- a <code><a class="el" href="classjem_1_1Slice.html" title="Selects parts of array-like objects.">Slice</a></code> or a valid integer index in the second dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A rectangular slice of this two-dimensional array.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>RANK == 2</code> <br  />
 and if <em>I</em> is an integer: <code>I &gt;= 0 &amp;&amp; I &lt; this-&gt;size(0)</code>; <br  />
 and if <em>J</em> is an integer: <code>J &gt;= 0 &amp;&amp; J &lt; this-&gt;size(1)</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ArraySlices.html">Array slices</a>. </dd></dl>

</div>
</div>
<a id="a245a69a675909bae6be81e88c670d69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245a69a675909bae6be81e88c670d69b">&#9670;&nbsp;</a></span>operator()() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
<div class="memtemplate">
template&lt;class S1 , class S2 , class S3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArraySlice <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const S1 &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S2 &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S3 &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a one-dimensional, two-dimensional or three-dimensional <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> object that refers to a rectangular section of this three-dimensional array. The returned array points to the same data block as this array.</p>
<p>Note that the return type <code>ArraySlice</code> is a dummy type; depending on the types of the template parameters <em>S1</em> and <em>S2</em>, <code>ArraySlice</code> is either equal to <code>Array&lt;T,1&gt;</code>, <code>Array&lt;T,2&gt;</code>, or <code>Array&lt;T,3&gt;</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I</td><td>- a <code><a class="el" href="classjem_1_1Slice.html" title="Selects parts of array-like objects.">Slice</a></code> or a valid integer index in the first dimension.</td></tr>
    <tr><td class="paramname">J</td><td>- a <code><a class="el" href="classjem_1_1Slice.html" title="Selects parts of array-like objects.">Slice</a></code> or a valid integer index in the second dimension.</td></tr>
    <tr><td class="paramname">K</td><td>- a <code><a class="el" href="classjem_1_1Slice.html" title="Selects parts of array-like objects.">Slice</a></code> or a valid integer index in the third dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A rectangular slice of this three-dimensional array.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>RANK == 3</code> <br  />
 and if <em>I</em> is an integer: <code>I &gt;= 0 &amp;&amp; I &lt; this-&gt;size(0)</code>; <br  />
 and if <em>J</em> is an integer: <code>J &gt;= 0 &amp;&amp; J &lt; this-&gt;size(1)</code>; <br  />
 and if <em>K</em> is an integer: <code>K &gt;= 0 &amp;&amp; K &lt; this-&gt;size(2)</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ArraySlices.html">Array slices</a>. </dd></dl>

</div>
</div>
<a id="a729bf23c298a2343c1685b2946bd4173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729bf23c298a2343c1685b2946bd4173">&#9670;&nbsp;</a></span>operator()() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
<div class="memtemplate">
template&lt;class S1 , class S2 , class S3 , class S4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArraySlice <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const S1 &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S2 &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S3 &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S4 &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a one-dimensional, two-dimensional, three-dimensional, or four-dimensional <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> object that refers to a rectangular section of this four-dimensional array. The returned array points to the same data block as this array.</p>
<p>Note that the return type <code>ArraySlice</code> is a dummy type; depending on the types of the template parameters <em>S1</em> and <em>S2</em>, <code>ArraySlice</code> is either equal to <code>Array&lt;T,1&gt;</code>, <code>Array&lt;T,2&gt;</code>, <code>Array&lt;T,3&gt;</code>, <code>Array&lt;T,4&gt;</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I</td><td>- a <code><a class="el" href="classjem_1_1Slice.html" title="Selects parts of array-like objects.">Slice</a></code> or a valid integer index in the first dimension.</td></tr>
    <tr><td class="paramname">J</td><td>- a <code><a class="el" href="classjem_1_1Slice.html" title="Selects parts of array-like objects.">Slice</a></code> or a valid integer index in the second dimension.</td></tr>
    <tr><td class="paramname">K</td><td>- a <code><a class="el" href="classjem_1_1Slice.html" title="Selects parts of array-like objects.">Slice</a></code> or a valid integer index in the third dimension.</td></tr>
    <tr><td class="paramname">L</td><td>- a <code><a class="el" href="classjem_1_1Slice.html" title="Selects parts of array-like objects.">Slice</a></code> or a valid integer index in the fourth dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A rectangular slice of this four-dimensional array.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>RANK == 4</code> <br  />
 and if <em>I</em> is an integer: <code>I &gt;= 0 &amp;&amp; I &lt; this-&gt;size(0)</code>; <br  />
 and if <em>J</em> is an integer: <code>J &gt;= 0 &amp;&amp; J &lt; this-&gt;size(1)</code>; <br  />
 and if <em>K</em> is an integer: <code>K &gt;= 0 &amp;&amp; K &lt; this-&gt;size(2)</code>; <br  />
 and if <em>L</em> is an integer: <code>L &gt;= 0 &amp;&amp; L &lt; this-&gt;size(3)</code>.<br  />
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ArraySlices.html">Array slices</a>. </dd></dl>

</div>
</div>
<a id="aec591eab80602216c7a42ec273482f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec591eab80602216c7a42ec273482f06">&#9670;&nbsp;</a></span>transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Array.html">Array</a> <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a view of this array with reversed dimensions. That is, the first dimension of the returned array corresponds with the last dimension of this array; the second dimension of the returned array correponds with the second to last dimension of this array; etc. The returned array points to the same data block as this array; any modifications to the returned array are therefore also visible in this array.</p>
<p>Here is an example:</p>
<div class="fragment"><div class="line">Array&lt;int,3&gt; a ( 3, 4, 5 );</div>
<div class="line">Array&lt;int,3&gt; b ( a.transpose() );</div>
<div class="line"> </div>
<div class="line">b        = 0;</div>
<div class="line">b(0,1,2) = 1;</div>
<div class="line">b(1,2,3) = 1;</div>
</div><!-- fragment --><p>After executing these statements, all elements of <code>a</code> are zero, except for the elements <code>a(2,1,0)</code> and <code>a(3,2,1)</code>.</p>
<p>This function is equivalent with:</p>
<div class="fragment"><div class="line">Tuple&lt;int,N&gt; perm;</div>
<div class="line"><span class="keywordtype">int</span>          i;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> ( i = 0; i &lt; N; i++ )</div>
<div class="line">{</div>
<div class="line">  perm[i] = N - i - 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">return</span> this-&gt;<a class="code" href="classjem_1_1Array.html#aec591eab80602216c7a42ec273482f06">transpose</a> ( perm );</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The transpose of this array. </dd></dl>

</div>
</div>
<a id="a1f9620d09bf6459f8f02c1ef04d4e746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9620d09bf6459f8f02c1ef04d4e746">&#9670;&nbsp;</a></span>transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Array.html">Array</a> <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1Tuple.html">Tuple</a>&lt; int, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the generalized transpose of this array. The transposed array contains the same elements as this array, but its dimensions have been permuted according to the <code><a class="el" href="classjem_1_1Tuple.html" title="Encapsulates a fixed-size, two-dimensional array.">Tuple</a></code> <em>perm</em>. To be precise, dimension 0 of the transposed array corresponds with dimension <code>perm[0]</code> of this array; dimension 1 of the transposed array corresponds with dimension <code>perm[1]</code> of this array; etc.</p>
<p>Example:</p>
<div class="fragment"><div class="line">Array&lt;int,3&gt; a ( 2, 2, 2   );</div>
<div class="line">Array&lt;int,3&gt; b ( a.shape() );</div>
<div class="line">Array&lt;int,3&gt; c ( a.shape() );</div>
<div class="line"> </div>
<div class="line">b = a.transpose ( <a class="code" href="namespacejem.html#aa32ec30c3f6970d229c7c07aca62ec1a">makeTuple</a>( 1, 0, 2 ) );</div>
<div class="line">c = a.transpose ( <a class="code" href="namespacejem.html#aa32ec30c3f6970d229c7c07aca62ec1a">makeTuple</a>( 2, 1, 0 ) );</div>
</div><!-- fragment --><p>After executing this code fragment, the following expressions will be true for all valid index tuples <em>(i j,k)</em>:</p>
<div class="fragment"><div class="line">b(j,i,k) == a(i,j,k);</div>
<div class="line">c(k,j,i) == a(i,j,k);</div>
</div><!-- fragment --><p>Note that the transposed array points to the same data block as this array; all modifications to the transposed array will therefore be visible in this array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>- a permutation <code><a class="el" href="classjem_1_1Tuple.html" title="Encapsulates a fixed-size, two-dimensional array.">Tuple</a></code> specifying how the dimensions of the transposed array are related to the dimensions of this array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generalized transpose of this array.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>RANK &gt; 1</code> </dd></dl>

</div>
</div>
<a id="a357c171ef4a03087138a32a1ce247ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357c171ef4a03087138a32a1ce247ff6">&#9670;&nbsp;</a></span>getFast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::getFast </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a reference to the <em>i-th</em> element stored in the part of the data block that this array is pointing to. The reference is valid as long as the data block pointed to by this array is not deallocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>- a valid index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="classjem_1_1Array.html#a39987f68c32eaa7af90a3d3571810964" title="Returns a pointer to the data stored in this array.">addr()</a>[i]</code> </dd></dl>

</div>
</div>
<a id="a0b40e1d3430559229015b3599d6915b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b40e1d3430559229015b3599d6915b5">&#9670;&nbsp;</a></span>isContiguous()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::isContiguous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests whether the elements of this array are stored contiguously in memory. A one-dimensional array is contiguous if its stride equals one. A multi-dimensional array is contiguous if the following two conditions are fulfilled:</p>
<ol type="1">
<li><code>stride(0) == 1</code>;</li>
<li><code>stride(i) == size(i - 1) * stride(i - 1)</code>.</li>
</ol>
<p>for all <em>0 &lt; i &lt; N</em>.</p>
<p>Note that a two-dimensional array is contiguous if its elements are stored contiguously in <em>column-major</em> order. Also note that the elements of a contiguous array are stored in the same way as the elements of a Fortran-77 array.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the elements of this array are stored contiguously in memory, and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a8f61ffd9580209f112de0a7545654632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f61ffd9580209f112de0a7545654632">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the size of this one-dimensional array to <em>m</em>. Calling this function has the same effect as:</p>
<p><code>this-&gt;resize ( shape(m) )</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>&ndash; the new size of this array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> RANK == 1 &amp;&amp; <br  />
 m &gt;= 0 </code></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>this-&gt;<a class="el" href="classjem_1_1Array.html#a89a82809f87ae1d823594e5ca4641c02" title="Returns the size of a one-dimensional array.">size()</a> == m</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classjem_1_1Array.html#a8f61ffd9580209f112de0a7545654632" title="Modifies the size of a one-dimensional array.">resize</a> ( const <a class="el" href="classjem_1_1Array.html#a43c76805b7fd33715287f423bc85667f" title="A type representing the shape of an array.">Shape</a>&amp; )</code> </dd></dl>

</div>
</div>
<a id="a5193bfbca3662dd0ca9ae70cc9b03b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5193bfbca3662dd0ca9ae70cc9b03b3b">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the shape of this two-dimensional array to <em>(m,n)</em>. Calling this function has the same effect as:</p>
<p><code>this-&gt;resize ( shape( m, n ) )</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>- the new array size in the first dimension. </td></tr>
    <tr><td class="paramname">n</td><td>- the new array size in the second dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> RANK == 2 &amp;&amp; <br  />
 m &gt;= 0 &amp;&amp; n &gt;= 0 </code></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code> this-&gt;size(0) == m &amp;&amp; <br  />
 this-&gt;size(1) == n </code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classjem_1_1Array.html#a8f61ffd9580209f112de0a7545654632" title="Modifies the size of a one-dimensional array.">resize</a> ( const <a class="el" href="classjem_1_1Array.html#a43c76805b7fd33715287f423bc85667f" title="A type representing the shape of an array.">Shape</a>&amp; )</code> </dd></dl>

</div>
</div>
<a id="a92954c9f82bd2ab6b511b40d84304de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92954c9f82bd2ab6b511b40d84304de3">&#9670;&nbsp;</a></span>resize() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the shape of this three-dimensional array to <em>(m,n,p)</em>. Calling this function has the same effect as:</p>
<p><code>this-&gt;resize ( shape( m, n, p ) )</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>- the new array size in the first dimension. </td></tr>
    <tr><td class="paramname">n</td><td>- the new array size in the second dimension. </td></tr>
    <tr><td class="paramname">p</td><td>- the new array size in the third dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> RANK == 3 &amp;&amp; <br  />
 m &gt;= 0 &amp;&amp; n &gt;= 0 &amp;&amp; p &gt;= 0 </code></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code> this-&gt;size(0) == m &amp;&amp; <br  />
 this-&gt;size(1) == n &amp;&amp; <br  />
 this-&gt;size(2) == p </code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classjem_1_1Array.html#a8f61ffd9580209f112de0a7545654632" title="Modifies the size of a one-dimensional array.">resize</a> ( const <a class="el" href="classjem_1_1Array.html#a43c76805b7fd33715287f423bc85667f" title="A type representing the shape of an array.">Shape</a>&amp; )</code> </dd></dl>

</div>
</div>
<a id="a47faa30a46eb797ee70d00f0ba233351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47faa30a46eb797ee70d00f0ba233351">&#9670;&nbsp;</a></span>resize() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the shape of this four-dimensional array to <em>(m,n,p,q)</em>. Calling this function has the same effect as:</p>
<p><code>this-&gt;resize ( shape( m, n, p, q ) )</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>- the new array size in the first dimension. </td></tr>
    <tr><td class="paramname">n</td><td>- the new array size in the second dimension. </td></tr>
    <tr><td class="paramname">p</td><td>- the new array size in the third dimension. </td></tr>
    <tr><td class="paramname">q</td><td>- the new array size in the fourth dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> RANK == 4 &amp;&amp; <br  />
 m &gt;= 0 &amp;&amp; n &gt;= 0 &amp;&amp; p &gt;= 0 &amp;&amp; q &gt;= 0 </code></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code> this-&gt;size(0) == m &amp;&amp; <br  />
 this-&gt;size(1) == n &amp;&amp; <br  />
 this-&gt;size(2) == p &amp;&amp; <br  />
 this-&gt;size(3) == q </code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classjem_1_1Array.html#a8f61ffd9580209f112de0a7545654632" title="Modifies the size of a one-dimensional array.">resize</a> ( const <a class="el" href="classjem_1_1Array.html#a43c76805b7fd33715287f423bc85667f" title="A type representing the shape of an array.">Shape</a>&amp; )</code> </dd></dl>

</div>
</div>
<a id="ae44d36d065b4b6e4eeb9879a8aa77701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44d36d065b4b6e4eeb9879a8aa77701">&#9670;&nbsp;</a></span>resize() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1Array.html#a43c76805b7fd33715287f423bc85667f">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>sh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the shape of this array to <em>sh</em>. From a logical point of view, calling this function has the same effect as executing the following statement:</p>
<p><code>this-&gt;ref ( Array&lt;T,N&gt;( sh ) )</code></p>
<p>However, there are two subtle differences between the <code>resize</code> function and the above statement. First, the <code>resize</code> function will re-use the data block this array is pointing to, provided that the block is large enough and that the block is not shared with another array. Consequently, the <code>resize</code> function can be significantly faster than the above statement. The second difference is that the <code>resize</code> function may not immediately call the destructor of the array elements that are no longer used (the destructor will be called eventually when the data block of the array is deallocated). This means that you should be careful when calling the resize function for an array containing elements with a non-trivial destructor.</p>
<p>The <code>resize</code> function does <em>not</em> preserve the contents of an array. That is, after calling the <code>resize</code> function you should not make any assumptions about the values of the array elements. Use the member function <code>reshape</code> if you want to modify the shape of an array and also preserve its contents.</p>
<p>An array is guaranteed to be contiguous after calling its <code>resize</code> member function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sh</td><td>- the new shape of this array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>min( sh ) &gt;= 0</code></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code> equal( this-&gt;<a class="el" href="classjem_1_1Array.html#a0590d1655d33fe77a7a2321ae4e7bfe9" title="Returns the shape of this array.">shape()</a>, sh ) &amp;&amp; <br  />
 this-&gt;<a class="el" href="classjem_1_1Array.html#a0b40e1d3430559229015b3599d6915b5" title="Tests whether this array is contiguous.">isContiguous()</a> </code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classjem_1_1Array.html#a6356e3d0c59d9ccb7d57bc44b53e57c1" title="Shrinks or expands an array.">reshape( const Shape&amp; )</a></code> </dd></dl>

</div>
</div>
<a id="a339ca875b6dbde9aeb920f5b5c94eebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339ca875b6dbde9aeb920f5b5c94eebf">&#9670;&nbsp;</a></span>reshape() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::reshape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shrinks or expands this one-dimensional array so that its size becomes <em>m</em>. Calling this function has the same effect as:</p>
<p><code>this-&gt;reshape ( shape(m) )</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>&ndash; the new size of this array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> RANK == 1 &amp;&amp; <br  />
 m &gt;= 0 </code></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>this-&gt;<a class="el" href="classjem_1_1Array.html#a89a82809f87ae1d823594e5ca4641c02" title="Returns the size of a one-dimensional array.">size()</a> == m</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classjem_1_1Array.html#a339ca875b6dbde9aeb920f5b5c94eebf" title="Shrinks or expands a one-dimensional array.">reshape</a> ( const <a class="el" href="classjem_1_1Array.html#a43c76805b7fd33715287f423bc85667f" title="A type representing the shape of an array.">Shape</a>&amp; )</code> </dd></dl>

</div>
</div>
<a id="a4ab4a0cce4de5e8b75ce9c5dc8b67db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab4a0cce4de5e8b75ce9c5dc8b67db7">&#9670;&nbsp;</a></span>reshape() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::reshape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shrinks or expands this two-dimensional array so that its shape becomes <em>(m,n)</em>. Calling this function has the same effect as:</p>
<p><code>this-&gt;reshape ( shape( m, n ) )</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>- the new array size in the first dimension. </td></tr>
    <tr><td class="paramname">n</td><td>- the new array size in the second dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> RANK == 2 &amp;&amp; <br  />
 m &gt;= 0 &amp;&amp; n &gt;= 0 </code></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code> this-&gt;size(0) == m &amp;&amp; <br  />
 this-&gt;size(1) == n </code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classjem_1_1Array.html#a339ca875b6dbde9aeb920f5b5c94eebf" title="Shrinks or expands a one-dimensional array.">reshape</a> ( const <a class="el" href="classjem_1_1Array.html#a43c76805b7fd33715287f423bc85667f" title="A type representing the shape of an array.">Shape</a>&amp; )</code> </dd></dl>

</div>
</div>
<a id="a8d30a1f58982f02c3f1f2830a53bd16a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d30a1f58982f02c3f1f2830a53bd16a">&#9670;&nbsp;</a></span>reshape() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::reshape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shrinks or expands this three-dimensional array so that its shape becomes <em>(m,n,p)</em>. Calling this function has the same effect as:</p>
<p><code>this-&gt;reshape ( shape( m, n, p ) )</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>- the new array size in the first dimension. </td></tr>
    <tr><td class="paramname">n</td><td>- the new array size in the second dimension. </td></tr>
    <tr><td class="paramname">p</td><td>- the new array size in the third dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> RANK == 3 &amp;&amp; <br  />
 m &gt;= 0 &amp;&amp; n &gt;= 0 &amp;&amp; p &gt;= 0 </code></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code> this-&gt;size(0) == m &amp;&amp; <br  />
 this-&gt;size(1) == n &amp;&amp; <br  />
 this-&gt;size(2) == p </code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classjem_1_1Array.html#a339ca875b6dbde9aeb920f5b5c94eebf" title="Shrinks or expands a one-dimensional array.">reshape</a> ( const <a class="el" href="classjem_1_1Array.html#a43c76805b7fd33715287f423bc85667f" title="A type representing the shape of an array.">Shape</a>&amp; )</code> </dd></dl>

</div>
</div>
<a id="a7c68b20af49d5205f663298fccc9b99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c68b20af49d5205f663298fccc9b99e">&#9670;&nbsp;</a></span>reshape() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::reshape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shrinks or expands this four-dimensional array so that its shape becomes <em>(m,n,p,q)</em>. Calling this function has the same effect as:</p>
<p><code>this-&gt;reshape ( shape( m, n, p, q ) )</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>- the new array size in the first dimension. </td></tr>
    <tr><td class="paramname">n</td><td>- the new array size in the second dimension. </td></tr>
    <tr><td class="paramname">p</td><td>- the new array size in the third dimension. </td></tr>
    <tr><td class="paramname">q</td><td>- the new array size in the fourth dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> RANK == 4 &amp;&amp; <br  />
 m &gt;= 0 &amp;&amp; n &gt;= 0 &amp;&amp; p &gt;= 0 &amp;&amp; q &gt;= 0 </code></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code> this-&gt;size(0) == m &amp;&amp; <br  />
 this-&gt;size(1) == n &amp;&amp; <br  />
 this-&gt;size(2) == p &amp;&amp; <br  />
 this-&gt;size(3) == q </code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classjem_1_1Array.html#a339ca875b6dbde9aeb920f5b5c94eebf" title="Shrinks or expands a one-dimensional array.">reshape</a> ( const <a class="el" href="classjem_1_1Array.html#a43c76805b7fd33715287f423bc85667f" title="A type representing the shape of an array.">Shape</a>&amp; )</code> </dd></dl>

</div>
</div>
<a id="a6356e3d0c59d9ccb7d57bc44b53e57c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6356e3d0c59d9ccb7d57bc44b53e57c1">&#9670;&nbsp;</a></span>reshape() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::reshape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1Array.html#a43c76805b7fd33715287f423bc85667f">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>sh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shrinks or expands this array so that its shape becomes <em>sh</em>. All elements of this array that are located within the shape <em>sh</em> are preserved. Any additional elements are initialized by calling the default constructor of type <code>T</code>. All elements within this array that are not located within the shape <em>sh</em> are destroyed by calling the destructor of type <code>T</code>.</p>
<p>If this array does not share its data with another array, the <code>reshape</code> function will try to expand or shrink its current data block. If that is not possible, or if the data block is shared with another array, the <code>reshape</code> function will allocate a new data block and copy the current array elements to that new block. To be precise, it only copies the elements that are located within the shape <em>sh</em> to the new block.</p>
<p>An array is guaranteed to be contiguous after calling its <code>reshape</code> member function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sh</td><td>- the new shape of this array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>min( sh ) &gt;= 0</code></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code> equal( this-&gt;<a class="el" href="classjem_1_1Array.html#a0590d1655d33fe77a7a2321ae4e7bfe9" title="Returns the shape of this array.">shape()</a>, sh ) &amp;&amp; <br  />
 this-&gt;<a class="el" href="classjem_1_1Array.html#a0b40e1d3430559229015b3599d6915b5" title="Tests whether this array is contiguous.">isContiguous()</a> </code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classjem_1_1Array.html#ae44d36d065b4b6e4eeb9879a8aa77701" title="Modifies the shape of an array.">resize( const Shape&amp; )</a></code> </dd></dl>

</div>
</div>
<a id="a89a82809f87ae1d823594e5ca4641c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a82809f87ae1d823594e5ca4641c02">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of elements stored in this one-dimensional array.</p>
<dl class="section return"><dt>Returns</dt><dd>The length of this array.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>RANK == 1</code> </dd></dl>

</div>
</div>
<a id="aac8ddb75562c94efd5d71405b724d680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8ddb75562c94efd5d71405b724d680">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size of this array in the dimension <em>dim</em>. For instance, if <code>a</code> is a two-dimensional array, then <code>a.size(0)</code> equals the number of rows, while <code>a.size(1)</code> equals the number of columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>- a dimension index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>this-&gt;<a class="el" href="classjem_1_1Array.html#a0590d1655d33fe77a7a2321ae4e7bfe9" title="Returns the shape of this array.">shape()</a>[dim]</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> dim &gt;= 0 &amp;&amp; dim &lt; N </code> </dd></dl>

</div>
</div>
<a id="ab55303228b2c4da5f070942511bcd9a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55303228b2c4da5f070942511bcd9a1">&#9670;&nbsp;</a></span>stride() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::stride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the stride of this one-dimensional array. The stride specifies how far apart the elements of this array are stored in memory. If the stride equals one, then all elements are stored contiguously in memory. In this case, the array is said to be contiguous.</p>
<p>You will probably need this function if you want to access the elements of a one-dimensional array directly.</p>
<dl class="section return"><dt>Returns</dt><dd>The stride of this array.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>RANK == 1</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>isContigous()</code>. </dd></dl>

</div>
</div>
<a id="a3ff0f5ed5d706da429e111accee042a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff0f5ed5d706da429e111accee042a8">&#9670;&nbsp;</a></span>stride() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::stride </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the stride of this array in the dimension <em>dim</em>. This stride specifies the distance (in terms of memory addresses) between two consecutive elements in the dimension <em>dim</em>.</p>
<p>You will probably need this function if you want to access the elements of an array directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>- the dimension index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stride of this array in the dimension <em>dim</em>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> dim &gt;= 0 &amp;&amp; dim &lt; N </code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>isContigous()</code>. </dd></dl>

</div>
</div>
<a id="a0590d1655d33fe77a7a2321ae4e7bfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0590d1655d33fe77a7a2321ae4e7bfe9">&#9670;&nbsp;</a></span>shape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Array.html#a43c76805b7fd33715287f423bc85667f">Shape</a> <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a tuple of length <em>N</em> containing the sizes of this array in all its dimensions. For instance, if this is a two-dimensional array with five rows and seven columns, then the function <code>shape</code> returns a tuple containing the values <em>(5,7)</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The shape of this array. </dd></dl>

</div>
</div>
<a id="a39987f68c32eaa7af90a3d3571810964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39987f68c32eaa7af90a3d3571810964">&#9670;&nbsp;</a></span>addr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::addr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the memory address of the first element stored in this array. This pointer remains valid as long as the data block is not deallocated.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the elements stored in this array. </dd></dl>

</div>
</div>
<a id="a404adc9ce3f1e46399bdf601576704ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404adc9ce3f1e46399bdf601576704ac">&#9670;&nbsp;</a></span>addr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::addr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the memory address of the <em>i-th</em> element stored in this one-dimensional array. The pointer remains valid as long as the data block is not deallocated.</p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="classjem_1_1Array.html#a39987f68c32eaa7af90a3d3571810964" title="Returns a pointer to the data stored in this array.">addr()</a> + ( <a class="el" href="classjem_1_1Array.html#ab55303228b2c4da5f070942511bcd9a1" title="Returns the stride of a one-dimensional array.">stride()</a> * i )</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>RANK == 1</code> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="af02e430770bc879a14382e43503e66bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02e430770bc879a14382e43503e66bf">&#9670;&nbsp;</a></span>shape() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Tuple.html">Tuple</a>&lt; int, 1 &gt; shape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <code><a class="el" href="classjem_1_1Tuple.html" title="Encapsulates a fixed-size, two-dimensional array.">Tuple</a></code> of length one that can be used to construct a one-dimensional <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> with shape <em>(n)</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- the element of the returned tuple.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>Tuple&lt;int,1&gt; ( n )</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>n &gt;= 0</code> </dd></dl>

</div>
</div>
<a id="ad995d4f79f78b0cd9e7dcceb55f8b6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad995d4f79f78b0cd9e7dcceb55f8b6d0">&#9670;&nbsp;</a></span>shape() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Tuple.html">Tuple</a>&lt; int, 2 &gt; shape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <code><a class="el" href="classjem_1_1Tuple.html" title="Encapsulates a fixed-size, two-dimensional array.">Tuple</a></code> of length two that can be used to construct a two-dimensional <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> with shape <em>(m,n)</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>- the first element of the returned tuple.</td></tr>
    <tr><td class="paramname">n</td><td>- the second element of the returned tuple.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="classjem_1_1Tuple.html">Tuple&lt;int,2&gt;</a> ( m, n )</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> m &gt;= 0 &amp;&amp; <br  />
 n &gt;= 0 </code> </dd></dl>

</div>
</div>
<a id="aa89cccf85e51fdcfea7d9c97a64e4473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89cccf85e51fdcfea7d9c97a64e4473">&#9670;&nbsp;</a></span>shape() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Tuple.html">Tuple</a>&lt; int, 3 &gt; shape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <code><a class="el" href="classjem_1_1Tuple.html" title="Encapsulates a fixed-size, two-dimensional array.">Tuple</a></code> of length three that can be used to construct a three-dimensional <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> with shape <em>(m,n,p)</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>- the first element of the returned tuple.</td></tr>
    <tr><td class="paramname">n</td><td>- the second element of the returned tuple.</td></tr>
    <tr><td class="paramname">p</td><td>- the third element of the returned tuple.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>Tuple&lt;int,3&gt; ( m, n, p )</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> m &gt;= 0 &amp;&amp; <br  />
 n &gt;= 0 &amp;&amp; <br  />
 p &gt;= 0 </code> </dd></dl>

</div>
</div>
<a id="ad24c4514db0abec13ebdd0089b584213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24c4514db0abec13ebdd0089b584213">&#9670;&nbsp;</a></span>shape() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1Tuple.html">Tuple</a>&lt; int, 4 &gt; shape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <code><a class="el" href="classjem_1_1Tuple.html" title="Encapsulates a fixed-size, two-dimensional array.">Tuple</a></code> of length four that can be used to construct a four-dimensional <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> with shape <em>(m,n,p,q)</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>- the first element of the returned tuple.</td></tr>
    <tr><td class="paramname">n</td><td>- the second element of the returned tuple.</td></tr>
    <tr><td class="paramname">p</td><td>- the third element of the returned tuple.</td></tr>
    <tr><td class="paramname">q</td><td>- the fourth element of the returned tuple.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>Tuple&lt;int,4&gt; ( m, n, p, q )</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code> m &gt;= 0 &amp;&amp; <br  />
 n &gt;= 0 &amp;&amp; <br  />
 p &gt;= 0 &amp;&amp; <br  />
 q &gt;= 0 </code> </dd></dl>

</div>
</div>
<a id="af9fb26ba923cb1e707327259760f9c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fb26ba923cb1e707327259760f9c54">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1io_1_1DataInput.html">io::DataInput</a> &amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjem_1_1io_1_1DataInput.html">io::DataInput</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classjem_1_1Array.html">Array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads an <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> from the data input stream <em>in</em> and assigns it to <em>a</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>- the <code>DataInputStream</code> from which the array is to be read.</td></tr>
    <tr><td class="paramname">a</td><td>- the <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>in</em> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjem_1_1io_1_1IOException.html" title="Signals an I/O error.">io::IOException</a></td><td>- if an IO error occurs.</td></tr>
    <tr><td class="paramname"><a class="el" href="classjem_1_1io_1_1SerializationException.html">io::SerializationException</a></td><td>- if the data input stream is corrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The following operator has been defined:<br  />
 <code><a class="el" href="classjem_1_1io_1_1DataInput.html">io::DataInput</a>&amp; operator &gt;&gt; ( <a class="el" href="classjem_1_1io_1_1DataInput.html">io::DataInput</a>&amp;, T&amp; )</code> </dd></dl>

</div>
</div>
<a id="a2aef2fdbf23aed7476587eb153baf529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aef2fdbf23aed7476587eb153baf529">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1io_1_1DataOutput.html">io::DataOutput</a> &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjem_1_1io_1_1DataOutput.html">io::DataOutput</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjem_1_1Array.html">Array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes the <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> <em>a</em> to the data output stream <em>out</em>. The de-serialization operator can be used to restore the <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>- the data output stream to which the array is to be written.</td></tr>
    <tr><td class="paramname">a</td><td>- the <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>out</em> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjem_1_1io_1_1IOException.html" title="Signals an I/O error.">io::IOException</a></td><td>- if an IO error occurs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The following operator has been defined:<br  />
 <code><a class="el" href="classjem_1_1io_1_1DataOutput.html">io::DataOutput</a>&amp; operator &lt;&lt; ( <a class="el" href="classjem_1_1io_1_1DataOutput.html">io::DataOutput</a>&amp;, const T&amp; )</code> </dd></dl>

</div>
</div>
<a id="a6b56dc7bb1b98575c94b7f8c3b4e2dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b56dc7bb1b98575c94b7f8c3b4e2dca">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjem_1_1io_1_1TextOutput.html">io::TextOutput</a> &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjem_1_1io_1_1TextOutput.html">io::TextOutput</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjem_1_1Array.html">Array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints the contents of the <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> <em>a</em> to the text output stream <em>out</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>- the text output stream to which the array is to be written.</td></tr>
    <tr><td class="paramname">a</td><td>- the array to be printed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>out</em> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjem_1_1io_1_1IOException.html" title="Signals an I/O error.">io::IOException</a></td><td>- if an IO error occurs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The following operator has been defined:<br  />
 <code><a class="el" href="classjem_1_1io_1_1TextOutput.html" title="Provides an interface for writing text-based output.">io::TextOutput</a>&amp; operator &lt;&lt; ( <a class="el" href="classjem_1_1io_1_1TextOutput.html" title="Provides an interface for writing text-based output.">io::TextOutput</a>&amp;, cont T&amp; )</code> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a77597496f4527fe05635d22caf3f9719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77597496f4527fe05635d22caf3f9719">&#9670;&nbsp;</a></span>RANK</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classjem_1_1Array.html">jem::Array</a>&lt; T, N &gt;::RANK = N</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>RANK</code> specifies the rank of the <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions.">Array</a></code> class. It is an integer constant equal to the second template parameter <em>N</em>. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="aclassjem_1_1Array_html_aec591eab80602216c7a42ec273482f06"><div class="ttname"><a href="classjem_1_1Array.html#aec591eab80602216c7a42ec273482f06">jem::Array::transpose</a></div><div class="ttdeci">Array transpose() const</div><div class="ttdoc">Returns the transpose of this array.</div></div>
<div class="ttc" id="anamespacejem_html_aa32ec30c3f6970d229c7c07aca62ec1a"><div class="ttname"><a href="namespacejem.html#aa32ec30c3f6970d229c7c07aca62ec1a">jem::makeTuple</a></div><div class="ttdeci">Tuple&lt; T, 1 &gt; makeTuple(T a)</div><div class="ttdoc">Constructs a one-dimensional tuple of size 1.</div></div>

<!-- Generated on Fri 20 Dec 14:45:31 CET 2019.
     CHANGES TO THIS FILE WILL BE LOST. -->
<hr class="footer"/>
<div class="footer">
  <a href="http://www.dynaflow.com">
    <img class="logo" align="left" src="logo.png"
      width="218" height="25" alt="logo" border="null"/>
  </a>
  <div align="right">
    <small>
      Generated on Fri Dec 20 2019 14:45:32 by Doxygen
    </small>
  </div>
</div>
</body>
</html>
